// src/contexts/DownloadContext.tsx
import React, {
  createContext,
  useContext,
  useState,
  useEffect,
  useCallback,
  ReactNode,
} from 'react';
import { DownloadTask, DownloadTaskCreationData } from '../types/download';
// Assuming DownloadStartResponse is similar to what /api/aria2/add returns (taskId, status, message)
// and DownloadStatusResponse is what /api/aria2/status/[taskId] returns (full task details or similar)
// We'll primarily work with DownloadTask for our state.

import { useToast } from '@/hooks/use-toast'; // Assuming this path is correct

// Defined in src/app/api/aria2/add/route.ts but re-defining for clarity if not exported from there.
interface DownloadStartResponse {
  taskId: string;
  status: DownloadTask['status'];
  message: string;
}

// Defined in src/app/api/aria2/status/[taskId]/route.ts
// This should ideally be imported if exported, or ensure fields match DownloadTask
interface ApiDownloadStatusResponse extends Omit<DownloadTask, 'createdAt' | 'updatedAt'> {
  // API might return date strings
  createdAt?: string;
  updatedAt?: string;
}


export interface DownloadContextValue {
  activeTasks: DownloadTask[];
  // downloadHistory: DownloadTask[]; // Future consideration
  addDownloadTask: (taskData: DownloadTaskCreationData) => Promise<DownloadTask | null>;
  refreshTaskStatus: (taskId: string) => Promise<DownloadTask | null>;
  getTask: (taskId: string) => DownloadTask | undefined;
  _simulateProgress: (taskId: string) => void; // For stubbing
}

const DownloadContext = createContext<DownloadContextValue | undefined>(undefined);

export function DownloadProvider({ children }: { children: ReactNode }) {
  const [activeTasks, setActiveTasks] = useState<DownloadTask[]>([]);
  const { toast } = useToast();

  const mapApiTaskToDownloadTask = (apiTask: ApiDownloadStatusResponse): DownloadTask => {
    return {
      ...apiTask,
      createdAt: apiTask.createdAt ? new Date(apiTask.createdAt) : new Date(),
      updatedAt: apiTask.updatedAt ? new Date(apiTask.updatedAt) : new Date(),
    };
  };

  const addDownloadTask = useCallback(
    async (taskData: DownloadTaskCreationData): Promise<DownloadTask | null> => {
      try {
        const response = await fetch('/api/aria2/add', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(taskData),
        });

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({ message: 'Failed to start download. Server returned an error.' }));
          console.error('Error starting download:', errorData);
          toast({
            title: 'Error Starting Download',
            description: errorData.error || errorData.message || 'Could not start download.',
            variant: 'destructive',
          });
          return null;
        }

        // Assuming the response from /api/aria2/add contains at least taskId
        const startResponse: DownloadStartResponse = await response.json();
        
        // Now fetch the full task details to get the complete DownloadTask object
        // This ensures we have all fields, including those generated by the server (like ID, initial status, timestamps)
        const statusResponse = await fetch(`/api/aria2/status/${startResponse.taskId}`);
        if (!statusResponse.ok) {
          const errorData = await statusResponse.json().catch(() => ({ message: 'Failed to fetch task details after creation.' }));
          console.error('Error fetching task status after add:', errorData);
          toast({
            title: 'Error Fetching Task Details',
            description: errorData.error || errorData.message || 'Could not fetch task details.',
            variant: 'destructive',
          });
          return null;
        }
        
        const newTaskFromApi: ApiDownloadStatusResponse = await statusResponse.json();
        const newTask = mapApiTaskToDownloadTask(newTaskFromApi);

        setActiveTasks((prevTasks) => [...prevTasks, newTask]);
        toast({
          title: 'Download Started',
          description: `${newTask.title} added to downloads.`,
        });
        return newTask;
      } catch (error) {
        console.error('Network error or other issue starting download:', error);
        toast({
          title: 'Error Starting Download',
          description: 'An unexpected error occurred.',
          variant: 'destructive',
        });
        return null;
      }
    },
    [toast]
  );

  const refreshTaskStatus = useCallback(
    async (taskId: string): Promise<DownloadTask | null> => {
      try {
        const response = await fetch(`/api/aria2/status/${taskId}`);
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({ message: `Failed to refresh status for task ${taskId}` }));
          if (response.status === 404) {
            toast({
              title: 'Task Not Found',
              description: `Task ${taskId} no longer exists.`,
              variant: 'destructive',
            });
            setActiveTasks((prevTasks) => prevTasks.filter((task) => task.id !== taskId));
          } else {
            // Avoid being too noisy for transient server errors during polling
            console.warn('Error refreshing task status:', errorData.error || errorData.message);
          }
          return null;
        }

        const updatedTaskFromApi: ApiDownloadStatusResponse = await response.json();
        const updatedTask = mapApiTaskToDownloadTask(updatedTaskFromApi);

        setActiveTasks((prevTasks) =>
          prevTasks.map((task) => (task.id === taskId ? updatedTask : task))
        );
        
        // Optional: Toast for significant status changes like completion or error
        if (updatedTask.status === 'completed' || updatedTask.status === 'error') {
            // Check if it was not already in that state to avoid repeated toasts
            const oldTask = activeTasks.find(t => t.id === taskId);
            if(oldTask && oldTask.status !== updatedTask.status){
                toast({
                    title: `Download ${updatedTask.status}`,
                    description: `${updatedTask.title} has ${updatedTask.status}.`,
                    variant: updatedTask.status === 'error' ? 'destructive' : undefined,
                });
            }
        }
        return updatedTask;
      } catch (error) {
        console.error(`Network error or other issue refreshing task ${taskId}:`, error);
        // Avoid toast here as this might be called by polling
        return null;
      }
    },
    [toast, activeTasks] // activeTasks needed for the oldTask check
  );

  const getTask = useCallback(
    (taskId: string): DownloadTask | undefined => {
      return activeTasks.find((task) => task.id === taskId);
    },
    [activeTasks]
  );

  const _simulateProgress = useCallback((taskId: string) => {
    setActiveTasks((prevTasks) =>
      prevTasks.map((task) => {
        if (task.id === taskId && task.status === 'downloading' && task.progress < 100) {
          const newProgress = Math.min(task.progress + 10, 100); // Simulate 10% increase
          const newDownloadedSize = task.fileSize ? (task.fileSize * newProgress) / 100 : (task.downloadedSize || 0) + (1024 * 1024 * Math.random() * 5); // Simulate some downloaded bytes
          return {
            ...task,
            progress: newProgress,
            downloadedSize: newDownloadedSize,
            speed: Math.random() * 5 * 1024 * 1024, // Random speed up to 5MB/s
            eta: task.fileSize && task.speed ? (task.fileSize - newDownloadedSize) / (task.speed || 1) : Math.max(0, (task.eta || 60) - 5),
            status: newProgress === 100 ? 'completed' : task.status,
            updatedAt: new Date(),
          };
        }
        return task;
      })
    );
  }, []);

  useEffect(() => {
    const interval = setInterval(() => {
      activeTasks.forEach((task) => {
        if (['queued', 'initializing', 'downloading'].includes(task.status)) {
          refreshTaskStatus(task.id);
        }
      });
    }, 5000); // Poll every 5 seconds

    return () => clearInterval(interval);
  }, [activeTasks, refreshTaskStatus]);

  const value = {
    activeTasks,
    addDownloadTask,
    refreshTaskStatus,
    getTask,
    _simulateProgress,
  };

  return (
    <DownloadContext.Provider value={value}>
      {children}
    </DownloadContext.Provider>
  );
}

export function useDownload() {
  const context = useContext(DownloadContext);
  if (context === undefined) {
    throw new Error('useDownload must be used within a DownloadProvider');
  }
  return context;
}
